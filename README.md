# Комп'ютерний проєкт
Тема: Порівняльний аналіз алгоритмів пошуку найкоротшого шляху

1. Постановка задачі
--------------------
Метою даної роботи є дослідження ефективності алгоритмів пошуку найкоротшого шляху в орієнтованих зважених графах з акцентом на розріджені графи. Проводиться імплементація класичних алгоритмів та інтеграція нового підходу (Duan et al., 2025) з подальшим бенчмаркінгом і аналізом залежності часу виконання від кількості вершин та коефіцієнта розрідженості.

Основні вимоги:
- Імплементація класичного алгоритму Дейкстри (Dijkstra).
- Імплементація алгоритму Беллмана–Форда (Bellman–Ford) для графів з від'ємними вагами.
- Імплементація / інтеграція алгоритму Duan et al. (2025) / BMSSP (у статусі розробки).
- Проведення порівняльного аналізу продуктивності щодо щільності графа (density) та числа вершин (n).

2. Опис реалізованих алгоритмів
--------------------------------

2.1 Алгоритм Беллмана–Форда (bellman_ford_algorithm)
Класичний алгоритм для знаходження найкоротших шляхів у графі, що може містити ребра з від'ємною вагою.

- Принцип роботи: ітеративне релаксування всіх ребер за N−1 ітерацій, перевірка негативних циклів на N-й ітерації.
- Складність: O(V·E).
- Особливості реалізації:
  - Працює з представленням графа у вигляді матриці суміжності.
  - Викидає ValueError при виявленні негативного циклу.
  - Відновлення шляху через масив батьків (parents).

2.2 Алгоритм Дейкстри (dijkstra_algorithm)
Алгоритм для графів з невід’ємними вагами.

- Принцип роботи: жадібний вибір невідвіданої вершини з мінімальною поточною відстанню та релаксування її сусідів.
- Особливості реалізації:
  - Працює над матрицею суміжності.
  - Повертає кортеж (distance, path), де path — список вершин від джерела до цілі.
  - Використовується допоміжна функція min_index для вибору наступної вершини (лінійний прохід).

2.3 Алгоритм Duan et al. (2025) / BMSSP (bmssp_path)
Сучасний підхід, описаний у роботі Duan et al. (2025), спрямований на пришвидшення пошуку в розріджених зважених графах.

- Статус: в процесі розробки / інтеграції.
- Ідея: багаторівневе рекурсивне скорочення області пошуку з вибором опорних вершин (pivots) та локальними пошуками, що дозволяє уникати повного сортування і в певних умовах наближуватися до O(E + V) або O(E + V log log V).
- Особливості реалізації:
  - Параметри керування: глибина рекурсії l, ліміт оброблюваних вершин k_param.
  - Повертає відновлений шлях і загальну відстань; при досягненні граничної глибини виконує локальний пошук (обмежена Дейкстра).

3. Технічна документація
------------------------

3.1. Алгоритми пошуку шляху — інтерфейси функцій

Функція: bellman_ford_algorithm(graph, start_vertex, end_vertex)
- graph: квадратна матриця суміжності (list[list[float]]), відсутність ребра — math.inf, діагональ = 0.
- start_vertex, end_vertex: цілі індекси вершин.
- Повертає: (distance: float, path: list[int]). Якщо шляху немає — distance = math.inf, path = [].

Функція: dijkstra_algorithm(graph, start_vertex, end_vertex)
- graph: матриця суміжності.
- start_vertex, end_vertex: індекси вершин.
- Повертає: (distance: float, path: list[int]).

Допоміжна логіка: min_index(distances, visited) — повертає індекс невідвіданої вершини з мінімальною відстанню (лінійний пошук).

3.2. Робота з даними та файлова система

Функція: load_csv_to_matrix(csv_path)
- Призначення: зчитування графа з CSV-файлу зі стрічками виду: source,target,weight.
- Логіка:
  - Парсинг рядків, формування множини унікальних вузлів.
  - Стабільне сортування вершин для побудови мапінгу імен → індексів.
  - Формування матриці N×N, ініціалізація math.inf, діагональ = 0.
  - Заповнення ваг ребер згідно з CSV.
- Повертає: матрицю суміжності (list[list[float]]) і мапінг імен вершин → індекси.

3.3. Генерація графів та бенчмаркінг

Функція: generate_sparse_directed_graph(n, density, max_w=10)
- n: кількість вершин.
- density: ймовірність наявності ребра між парою вершин (0.0–1.0). Рекомендовані значення для тестів: 0.05–0.7.
- max_w: максимальна вага ребра (інтегер).
- Логіка: створює матрицю n×n, встановлює math.inf, діагональ = 0; для кожної пари (i, j), i != j, з імовірністю density створює ребро з ваги ∈ [1, max_w].
- Повертає: матрицю суміжності.

Функція: run_benchmark_with_bellman(algorithms, generator_func, n_nodes, output_file, density_list)
- Призначення: запуск серії експериментів та побудова графіків часу виконання.
- Вхідні параметри:
  - algorithms: словник реалізованих алгоритмів (напр., {"dijkstra": dijkstra_algorithm, "bellman": bellman_ford_algorithm, "bmssp": bmssp_path}).
  - generator_func: функція генерації випадкового графа (generate_sparse_directed_graph).
  - n_nodes: кількість вершин для серії тестів.
  - output_file: шлях для збереження зображення результата (png/jpg/svg/pdf).
  - density_list: список коефіцієнтів щільності для ітерацій.
- Логіка:
  - Для кожної щільності генерує граф (за фіксованим seed, якщо потрібно), вимірює час роботи кожного алгоритму, зберігає середні/медіанні значення.
  - Візуалізація результатів (matplotlib) — залежність часу від density (логарифмічна шкала по часу при необхідності).
  - Збереження графіка у файл.

Функція: bmssp_path(graph, source, target, l=2, k_param=50)
- Реалізація ідеї Duan et al. (BMSSP-подібний підхід).
- Параметри:
  - graph: матриця суміжності.
  - source, target: індекси вершин.
  - l: глибина рекурсії (int, за замовчуванням 2).
  - k_param: макс. кількість вершин для локального пошуку (int, за замовчуванням 50).
- Логіка:
  - Ініціалізація dist, parent; dist[source] = 0.
  - Рекурсивна процедура bmssp_recur(S, l) де S — множина кандидатів:
    - Якщо l ≤ 0: локальний обмежений пошук (Дейкстра) серед k_param+1 найближчих вершин.
    - Інакше: вибір опорних вершин (find_pivots), рекурсивні виклики для кожної опорної вершини, оновлення dist для суміжних вершин.
  - Після завершення відновлення шляху через parent.
- Повертає: (total_distance: float, path_edges: list[tuple[int,int]] або list[int]).

Допоміжна функція: find_pivots(graph, dist, S, k_steps, p_limit)
- Призначення: вибір опорних вершин (pivots) та обчислення множини досяжних вершин у межах k_steps.
- Логіка:
  - Сортування множини S за зростанням dist.
  - Вибір перших p_limit вершин як P.
  - З кожної опорної вершини виконання обмеженого BFS/DFS на k_steps кроків для побудови W — множини досяжних вершин.
- Повертає: (P, W).

3.4. Взаємодія та головний модуль

Функція: main()
- Координує парсинг аргументів командного рядка, ініціалізацію графа (генерація або завантаження), запуск обраних алгоритмів та опційний бенчмаркінг.
- Валідація вхідних параметрів та обробка помилок.

Аргументи командного рядка (рекомендований набір)
- -n, --nodes (int, default: 500) — кількість вершин.
- -d, --density (float, default: 0.3) — коефіцієнт щільності/розрідженості.
- -w, --max-weight (int, default: 10) — максимальна вага ребра.
- --start (int, default: 0) — індекс стартової вершини.
- --target (int, optional) — індекс цільової вершини (за замовчуванням n-1).
- -l, --recursion-depth (int, default: 2) — глибина рекурсії для BMSSP.
- --source (str, optional) — шлях до CSV-файлу для завантаження графа (формат: source,target,weight).
- --force-benchmark (flag) — змусити запуск бенчмарку навіть при завантаженому CSV.
- --benchmark-output (str, default: "benchmark.png") — ім'я файлу для збереження графіку.
- --print-matrix (flag) — вивести матрицю суміжності (рекомендується лише для n ≤ 20).

Правила поведінки при конфлікті аргументів:
- Якщо вказано --source, аргументи -n/-d/-w ігноруються.
- --force-benchmark дозволяє виконувати бенчмарк навіть при завантаженні CSV.
- Індекси start/target автоматично коригуються, якщо виходять за діапазон [0, n-1]; при некоректному файлі CSV програма завершується з повідомленням.

4. Висновок
-----------
Проєкт реалізує універсальну платформу для порівняльного аналізу алгоритмів пошуку найкоротшого шляху в орієнтованих зважених графах. Основні можливості:

- Генерація випадкових розріджених графів різних розмірів і щільності.
- Імплементація та порівняння Дейкстри, Беллмана–Форда та експериментального BMSSP (Duan et al., 2025).
- Модульне налаштування параметрів BMSSP (глибина рекурсії, ліміти).
- Автоматизований бенчмаркінг із візуалізацією результатів.
- Підтримка завантаження реальних даних з CSV.

5. Розподіл обов'язків
---------------------
Робота над проєктом була розподілена між членами команди наступним чином:

- Максим — Класичні алгоритми
  Реалізація алгоритму Дейкстри

- Олександр та Настя — Новий алгоритм
  Дослідження та імплементація ідей Duan et al. (2025), оптимізація структур даних, інтеграція BMSSP в загальну архітектуру.

- Юлія — Генерація даних
  Реалізація генератора випадкових розріджених графів для тестування (generate_sparse_directed_graph), підготовка сценаріїв для бенчмарків.

- Андрій — Аналітика та візуалізація
  Зчитування графів з CSV, модуль бенчмаркінгу (run_benchmark_with_bellman), побудова графіків (matplotlib), збирання статистики.
